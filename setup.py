# Setup script for the DOOMERCAT python module.
#
# Author: Malte J. Ziebarth (ziebarth@gfz-potsdam.de)
#
# Copyright (C) 2019-2022 Deutsches GeoForschungsZentrum Potsdam
#
# Licensed under the EUPL, Version 1.2 or â€“ as soon they will be approved by
# the European Commission - subsequent versions of the EUPL (the "Licence");
# You may not use this work except in compliance with the Licence.
# You may obtain a copy of the Licence at:
#
# https://joinup.ec.europa.eu/collection/eupl/eupl-text-eupl-12
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the Licence is distributed on an "AS IS" basis,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the Licence for the specific language governing permissions and
# limitations under the Licence.

# Imports:
from setuptools import setup, Command
from setuptools.command.build import build, SubCommand
from setuptools.command.bdist_wheel import bdist_wheel


import os
import tarfile
import subprocess
from glob import glob
from pathlib import Path
from shutil import copyfile

try:
    platform_tag = os.environ["MANYLINUX_PLATFORM_TAG"]
except KeyError:
    platform_tag = None

DIR_LINUX = 'builddir'
DIR_CROSS = 'builddir-mingw'

# Compile the C++ code:
def setup_compile(build_lib: str):
    """
    This function can be called from the setup script to compile with
    the Meson backend.
    """
    print("build_lib:",build_lib)
    # First setup the meson directories:
    parent = Path('.').resolve()
    destination = Path(build_lib)
    def meson_setup(*options: str, force=False):
        os.chdir(parent)
        if os.name == 'posix':
            if not (parent / DIR_LINUX).is_dir() or force:
                cmd = ('meson', 'setup', *options, DIR_LINUX)
                subprocess.run(cmd, check=True)
        elif os.name == 'nt':
            if not (parent / DIR_CROSS).is_dir() or force:
                cmd = ('meson','setup','--cross-file','x86_64-w64-mingw32.txt',
                    *options, DIR_CROSS)
                subprocess.run(cmd, check=True)

    meson_setup()

    # Now compile:
    def compile():
        cmd = ('meson','compile')
        if os.name == 'posix':
            os.chdir(parent / DIR_LINUX)
            subprocess.run(cmd, check=True)

        elif os.name == 'nt':
            os.chdir(parent / DIR_CROSS)
            subprocess.run(cmd, check=True)

    recompile = True
    try:
        compile()
        recompile = False
    except:
        # Most probably the build directory was generated by an old
        # Meson version or is otherwise corrupt.
        # Wipe the build directory and rebuild:
        pass

    if recompile:
        meson_setup('--reconfigure', force=True)
        compile()

    os.chdir(parent)

    # Now copy the shared libraries:
    if os.name == 'posix':
        copyfile(
            parent / DIR_LINUX / "lib_cppextensions.so",
            destination / "doomercat" / "_cppextensions.so"
        )
    elif os.name == 'nt':
        copyfile(
            parent / DIR_CROSS / "lib_cppextensions.dll",
            destination / "doomercat" / "_cppextensions.dll"
        )

    # Archive and copy the sources:
    archive = destination/ "doomercat" / "_sources.tar.bz2"
    with tarfile.open(archive, 'w:bz2') as tar:
        for f in glob("*.hpp", root_dir=parent / "cpp" / "include"):
            fp = parent / "cpp" / "include" / f
            tar.add(fp, fp.relative_to(parent))
        for f in glob("*.cpp", root_dir=parent / "cpp" / "src"):
            fp = parent / "cpp" / "src" / f
            tar.add(fp, fp.relative_to(parent))

    subprocess.run(("pwd"))
    subprocess.run(("ls",str((destination / "doomercat").resolve())))



class BuildDoomercatCommand(SubCommand, Command):
    """
    Custom command to build the Doomercat shared libraries.
    """
    parent: Path

    def initialize_options(self) -> None:
        self.parent = Path('.').resolve()

    def finalize_options(self) -> None:
        pass

    def get_source_files(self) -> list[str]:
        """
        Parse the meson.build file to obtain the list of sources.
        """
        with open('meson.build','r') as f:
            meson_build = f.readlines()
        sources = []
        in_sources = False
        for line in meson_build:
            if line.startswith("sources = ["):
                in_sources = True

            if in_sources:
                sources.append(line.split('[')[-1].split(']')[0])

            if in_sources and line.strip().endswith("]"):
                in_sources = False

        sources = [s.strip() for src in sources for s in src.split(',')]
        print("sources:",sources)
        return sources

    def run(self) -> None:
        setup_compile(self.get_finalized_command("build_py").build_lib)

    def get_outputs(self, include_bytecode=True) -> list[str]:
        outputs = [
            str((self.parent / DIR_LINUX / "lib_cppextensions.so")
                 .relative_to(self.parent)),
            str((self.parent / DIR_CROSS / "lib_cppextensions.dll")
                 .relative_to(self.parent))
        ]
        return outputs



class DummyBuild(build):
    """
    Places the build_doomercat at the end of the build command queue,
    enabling it to build and copy the shared libraries into the existing
    build directory.
    """
    sub_commands = build.sub_commands + [('build_doomercat', None)]

    def __init__(self, *args, **kwargs):
        print("sub_commands:", DummyBuild.sub_commands)
        super().__init__(*args, **kwargs)


class patched_bdist_wheel(bdist_wheel):
    def finalize_options(self) -> None:
        super().finalize_options()
        self.root_is_pure = False
        if platform_tag is not None:
            self.plat_name = platform_tag
            self.plat_name_supplied  =True


# Setup:

setup(
    cmdclass = {
        'build' : DummyBuild,
        'build_doomercat' : BuildDoomercatCommand,
        'bdist_wheel' : patched_bdist_wheel
    }
)
